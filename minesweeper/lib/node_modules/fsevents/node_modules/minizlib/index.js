'use strict';

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var assert = require('assert');
var Buffer = require('buffer').Buffer;
var binding = process.binding('zlib');

var constants = exports.constants = require('./constants.js');
var MiniPass = require('minipass');

var ZlibError = function (_Error) {
  _inherits(ZlibError, _Error);

  function ZlibError(msg, errno) {
    _classCallCheck(this, ZlibError);

    var _this = _possibleConstructorReturn(this, (ZlibError.__proto__ || Object.getPrototypeOf(ZlibError)).call(this, 'zlib: ' + msg));

    _this.errno = errno;
    _this.code = codes.get(errno);
    return _this;
  }

  _createClass(ZlibError, [{
    key: 'name',
    get: function get() {
      return 'ZlibError';
    }
  }]);

  return ZlibError;
}(Error);

// translation table for return codes.


var codes = new Map([[constants.Z_OK, 'Z_OK'], [constants.Z_STREAM_END, 'Z_STREAM_END'], [constants.Z_NEED_DICT, 'Z_NEED_DICT'], [constants.Z_ERRNO, 'Z_ERRNO'], [constants.Z_STREAM_ERROR, 'Z_STREAM_ERROR'], [constants.Z_DATA_ERROR, 'Z_DATA_ERROR'], [constants.Z_MEM_ERROR, 'Z_MEM_ERROR'], [constants.Z_BUF_ERROR, 'Z_BUF_ERROR'], [constants.Z_VERSION_ERROR, 'Z_VERSION_ERROR']]);

var validFlushFlags = new Set([constants.Z_NO_FLUSH, constants.Z_PARTIAL_FLUSH, constants.Z_SYNC_FLUSH, constants.Z_FULL_FLUSH, constants.Z_FINISH, constants.Z_BLOCK]);

var strategies = new Set([constants.Z_FILTERED, constants.Z_HUFFMAN_ONLY, constants.Z_RLE, constants.Z_FIXED, constants.Z_DEFAULT_STRATEGY]);

// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.
var _opts = Symbol('opts');
var _chunkSize = Symbol('chunkSize');
var _flushFlag = Symbol('flushFlag');
var _finishFlush = Symbol('finishFlush');
var _handle = Symbol('handle');
var _hadError = Symbol('hadError');
var _buffer = Symbol('buffer');
var _offset = Symbol('offset');
var _level = Symbol('level');
var _strategy = Symbol('strategy');
var _ended = Symbol('ended');
var _writeState = Symbol('writeState');

var Zlib = function (_MiniPass) {
  _inherits(Zlib, _MiniPass);

  function Zlib(opts, mode) {
    _classCallCheck(this, Zlib);

    var _this2 = _possibleConstructorReturn(this, (Zlib.__proto__ || Object.getPrototypeOf(Zlib)).call(this, opts));

    _this2[_ended] = false;
    _this2[_opts] = opts = opts || {};
    _this2[_chunkSize] = opts.chunkSize || constants.Z_DEFAULT_CHUNK;
    if (opts.flush && !validFlushFlags.has(opts.flush)) {
      throw new TypeError('Invalid flush flag: ' + opts.flush);
    }
    if (opts.finishFlush && !validFlushFlags.has(opts.finishFlush)) {
      throw new TypeError('Invalid flush flag: ' + opts.finishFlush);
    }

    _this2[_flushFlag] = opts.flush || constants.Z_NO_FLUSH;
    _this2[_finishFlush] = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : constants.Z_FINISH;

    if (opts.chunkSize) {
      if (opts.chunkSize < constants.Z_MIN_CHUNK) {
        throw new RangeError('Invalid chunk size: ' + opts.chunkSize);
      }
    }

    if (opts.windowBits) {
      if (opts.windowBits < constants.Z_MIN_WINDOWBITS || opts.windowBits > constants.Z_MAX_WINDOWBITS) {
        throw new RangeError('Invalid windowBits: ' + opts.windowBits);
      }
    }

    if (opts.level) {
      if (opts.level < constants.Z_MIN_LEVEL || opts.level > constants.Z_MAX_LEVEL) {
        throw new RangeError('Invalid compression level: ' + opts.level);
      }
    }

    if (opts.memLevel) {
      if (opts.memLevel < constants.Z_MIN_MEMLEVEL || opts.memLevel > constants.Z_MAX_MEMLEVEL) {
        throw new RangeError('Invalid memLevel: ' + opts.memLevel);
      }
    }

    if (opts.strategy && !strategies.has(opts.strategy)) throw new TypeError('Invalid strategy: ' + opts.strategy);

    if (opts.dictionary) {
      if (!(opts.dictionary instanceof Buffer)) {
        throw new TypeError('Invalid dictionary: it should be a Buffer instance');
      }
    }

    _this2[_handle] = new binding.Zlib(mode);

    _this2[_hadError] = false;
    _this2[_handle].onerror = function (message, errno) {
      // there is no way to cleanly recover.
      // continuing only obscures problems.
      _this2.close();
      _this2[_hadError] = true;

      var error = new ZlibError(message, errno);
      _this2.emit('error', error);
    };

    var level = typeof opts.level === 'number' ? opts.level : constants.Z_DEFAULT_COMPRESSION;

    var strategy = typeof opts.strategy === 'number' ? opts.strategy : constants.Z_DEFAULT_STRATEGY;

    _this2[_writeState] = new Uint32Array(2);
    var window = opts.windowBits || constants.Z_DEFAULT_WINDOWBITS;
    var memLevel = opts.memLevel || constants.Z_DEFAULT_MEMLEVEL;

    // API changed in node v9
    /* istanbul ignore next */
    if (/^v[0-8]\./.test(process.version)) {
      _this2[_handle].init(window, level, memLevel, strategy, opts.dictionary);
    } else {
      _this2[_handle].init(window, level, memLevel, strategy, _this2[_writeState], function () {}, opts.dictionary);
    }

    _this2[_buffer] = Buffer.allocUnsafe(_this2[_chunkSize]);
    _this2[_offset] = 0;
    _this2[_level] = level;
    _this2[_strategy] = strategy;

    _this2.once('end', _this2.close);
    return _this2;
  }

  _createClass(Zlib, [{
    key: 'close',
    value: function close() {
      if (this[_handle]) {
        this[_handle].close();
        this[_handle] = null;
        this.emit('close');
      }
    }
  }, {
    key: 'params',
    value: function params(level, strategy) {
      if (!this[_handle]) throw new Error('cannot switch params when binding is closed');

      // no way to test this without also not supporting params at all
      /* istanbul ignore if */
      if (!this[_handle].params) throw new Error('not supported in this implementation');

      if (level < constants.Z_MIN_LEVEL || level > constants.Z_MAX_LEVEL) {
        throw new RangeError('Invalid compression level: ' + level);
      }

      if (!strategies.has(strategy)) throw new TypeError('Invalid strategy: ' + strategy);

      if (this[_level] !== level || this[_strategy] !== strategy) {
        this.flush(constants.Z_SYNC_FLUSH);
        assert(this[_handle], 'zlib binding closed');
        this[_handle].params(level, strategy);
        /* istanbul ignore else */
        if (!this[_hadError]) {
          this[_level] = level;
          this[_strategy] = strategy;
        }
      }
    }
  }, {
    key: 'reset',
    value: function reset() {
      assert(this[_handle], 'zlib binding closed');
      return this[_handle].reset();
    }
  }, {
    key: 'flush',
    value: function flush(kind) {
      if (kind === undefined) kind = constants.Z_FULL_FLUSH;

      if (this.ended) return;

      var flushFlag = this[_flushFlag];
      this[_flushFlag] = kind;
      this.write(Buffer.alloc(0));
      this[_flushFlag] = flushFlag;
    }
  }, {
    key: 'end',
    value: function end(chunk, encoding, cb) {
      if (chunk) this.write(chunk, encoding);
      this.flush(this[_finishFlush]);
      this[_ended] = true;
      return _get(Zlib.prototype.__proto__ || Object.getPrototypeOf(Zlib.prototype), 'end', this).call(this, null, null, cb);
    }
  }, {
    key: 'write',
    value: function write(chunk, encoding, cb) {
      // process the chunk using the sync process
      // then super.write() all the outputted chunks
      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';

      if (typeof chunk === 'string') chunk = new Buffer(chunk, encoding);

      var availInBefore = chunk && chunk.length;
      var availOutBefore = this[_chunkSize] - this[_offset];
      var inOff = 0; // the offset of the input buffer
      var flushFlag = this[_flushFlag];
      var writeReturn = true;

      assert(this[_handle], 'zlib binding closed');
      do {
        var res = this[_handle].writeSync(flushFlag, chunk, // in
        inOff, // in_off
        availInBefore, // in_len
        this[_buffer], // out
        this[_offset], //out_off
        availOutBefore // out_len
        );

        if (this[_hadError]) break;

        // API changed in v9
        /* istanbul ignore next */
        var availInAfter = res ? res[0] : this[_writeState][1];
        /* istanbul ignore next */
        var availOutAfter = res ? res[1] : this[_writeState][0];

        var have = availOutBefore - availOutAfter;
        assert(have >= 0, 'have should not go down');

        if (have > 0) {
          var out = this[_buffer].slice(this[_offset], this[_offset] + have);

          this[_offset] += have;
          // serve some output to the consumer.
          writeReturn = _get(Zlib.prototype.__proto__ || Object.getPrototypeOf(Zlib.prototype), 'write', this).call(this, out) && writeReturn;
        }

        // exhausted the output buffer, or used all the input create a new one.
        if (availOutAfter === 0 || this[_offset] >= this[_chunkSize]) {
          availOutBefore = this[_chunkSize];
          this[_offset] = 0;
          this[_buffer] = Buffer.allocUnsafe(this[_chunkSize]);
        }

        if (availOutAfter === 0) {
          // Not actually done.  Need to reprocess.
          // Also, update the availInBefore to the availInAfter value,
          // so that if we have to hit it a third (fourth, etc.) time,
          // it'll have the correct byte counts.
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          continue;
        }
        break;
      } while (!this[_hadError]);

      if (cb) cb();
      return writeReturn;
    }
  }, {
    key: 'ended',
    get: function get() {
      return this[_ended];
    }
  }]);

  return Zlib;
}(MiniPass);

// minimal 2-byte header


var Deflate = function (_Zlib) {
  _inherits(Deflate, _Zlib);

  function Deflate(opts) {
    _classCallCheck(this, Deflate);

    return _possibleConstructorReturn(this, (Deflate.__proto__ || Object.getPrototypeOf(Deflate)).call(this, opts, constants.DEFLATE));
  }

  return Deflate;
}(Zlib);

var Inflate = function (_Zlib2) {
  _inherits(Inflate, _Zlib2);

  function Inflate(opts) {
    _classCallCheck(this, Inflate);

    return _possibleConstructorReturn(this, (Inflate.__proto__ || Object.getPrototypeOf(Inflate)).call(this, opts, constants.INFLATE));
  }

  return Inflate;
}(Zlib);

// gzip - bigger header, same deflate compression


var Gzip = function (_Zlib3) {
  _inherits(Gzip, _Zlib3);

  function Gzip(opts) {
    _classCallCheck(this, Gzip);

    return _possibleConstructorReturn(this, (Gzip.__proto__ || Object.getPrototypeOf(Gzip)).call(this, opts, constants.GZIP));
  }

  return Gzip;
}(Zlib);

var Gunzip = function (_Zlib4) {
  _inherits(Gunzip, _Zlib4);

  function Gunzip(opts) {
    _classCallCheck(this, Gunzip);

    return _possibleConstructorReturn(this, (Gunzip.__proto__ || Object.getPrototypeOf(Gunzip)).call(this, opts, constants.GUNZIP));
  }

  return Gunzip;
}(Zlib);

// raw - no header


var DeflateRaw = function (_Zlib5) {
  _inherits(DeflateRaw, _Zlib5);

  function DeflateRaw(opts) {
    _classCallCheck(this, DeflateRaw);

    return _possibleConstructorReturn(this, (DeflateRaw.__proto__ || Object.getPrototypeOf(DeflateRaw)).call(this, opts, constants.DEFLATERAW));
  }

  return DeflateRaw;
}(Zlib);

var InflateRaw = function (_Zlib6) {
  _inherits(InflateRaw, _Zlib6);

  function InflateRaw(opts) {
    _classCallCheck(this, InflateRaw);

    return _possibleConstructorReturn(this, (InflateRaw.__proto__ || Object.getPrototypeOf(InflateRaw)).call(this, opts, constants.INFLATERAW));
  }

  return InflateRaw;
}(Zlib);

// auto-detect header.


var Unzip = function (_Zlib7) {
  _inherits(Unzip, _Zlib7);

  function Unzip(opts) {
    _classCallCheck(this, Unzip);

    return _possibleConstructorReturn(this, (Unzip.__proto__ || Object.getPrototypeOf(Unzip)).call(this, opts, constants.UNZIP));
  }

  return Unzip;
}(Zlib);

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;